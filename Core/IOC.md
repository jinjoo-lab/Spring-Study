# IOC

### 스프링 컨테이너

- 스프링 컨테이너 (애플리케이션 컨텍스트) : 스프링 런타임 엔진 , 설정 정보를 참고하여 애플리케이션을 구성하는 오브젝트를 생성 , 관리

### 오브젝트 팩토리

- 인터페이스화된 클래스에 대해 구체적으로 어떤 구현 클래스를 사용할 것인지 결정
- 객체 생성에 대한 주도권을 가지고 있는 클래스

### 팩토리 클래스

- 객체의 생성 방법을 결정하고 만들어진 오브젝트를 반환
- 사용 이유
    - 오브젝트를 생성하는 쪽과 사용하는 쪽의 역할을 분리

### 제어의 역전 - 프로그래밍적 관점

- 프로그램 제어 흐름 구조가 바뀌는 것 ( 프로그램의 주도권이 바뀌는 것 )

**예시**

> UserDao 라는 클래스로 예시를 들어보겠습니다. 여기서 UserDao 클래스는 사용자의 정보를 DB에 넣고 관리할 수 있는 클래스입니다. (《토비의 스프링》 1장 ‘초난감 DAO’에서 가져옴) UserDao 클래스가 하는 역할은 User도메인에 해당하는 **데이터 모델에 대해 접근**하고 쓰고, 수정하는 역할을 수행
>

```kotlin
class UserDao {
	fun readUser() {}
	fun createUser() {}	
}
```

- UserDao 라는 클래스를 가져다 쓰는 경우를 생각 해봅시다. 가장 쉽게 떠오르는 자연스러운 흐름은 userDao 클래스의 인스턴스를 만드는 겁니다. 그러나 userDao 클래스 자체만으로는 무언가를 수행할 수는 없고, `ConnectionMaker` 라는 DB 연결을 도와주는 클래스에 생성자로 넘겨줘야합니다. 그래서 아래와 같이  UserDao는 main내에서 생성되고 `ConnectionMaker` 생성자에 userDao를 넘겨줌

```kotlin
fun main() {
	val userDao = UserDao()
	val connectionMaker = ConnectionMaker(userDao)
	connectionMaker.disconnect()
}
```

- 위와 같은 방식은 IOC가 적용되지 않은 방식입니다. 개발자가 코드에 ConnectionMaker에 대한 제어 (주입)을 직접 시행하였습니다.

```kotlin
fun main(connectionMaker: ConnectionMaker) { 
	connectionMaker.disconnect()
}
```

- 첫번째 예시와 다르게 main에서 connectionMaker에 대해 직접 제어 하지 않습니다. connectionMaker 에 대한 인스턴스 생성은 main 에서 이뤄지지 않고 main을 호출하는 또 다른 어딘가에서 이를 관리합니다. 이러한 구현 패턴을 우리는 **제어의 역전** 이라고 부릅니다.
- **Why Spring Use IOC ?**
    - 객체 간의 결합도를 낮출 수 있다.
    - 제어와 실제 로직간의 분리를 통해 (관심사의 분리) 개발자는 로직 구현에만 집중할 수 있다.
    - 유지 보수가 쉽다. (결합도 자체가 낮기 때문에 !)

### 차이점

기존 프로그래밍에서는 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정 , 오브젝트의 생성 , 생명 주기를 관장한다. 사용하는 쪽에서 제어하는 구조

제어의 역전이 적용된 프로그래밍의 관점에서는 오브젝트가 자신이 사용할 오브젝트를 결정하지 않는다. 제어 권한을 자신이 아닌 다른 대상에게 위임

## 제어의 역전 예시

### 서블릿

- 사용자가 서블릿을 직접 제어하는 방법은 없다. 서블릿에 대한 제어 권한을 가진 컨테이너가 서블릿 클래스의 오브젝트를 생성하고 메소드를 호출
- 서블릿 컨테이너가 요청을 받은 시점에 서블릿을 생성 하고 해당 서블릿의 메소드를 호출

### 프레임워크

- 라이브러리 : 라이브러리를 사용하는 애플리케이션 코드 (개발자)가 애플리케이션의 흐름을 제어한다. 필요한 순간 개발자가 능동적으로 라이브러리를 호출하여 사용하는 방식 / 주도권이 개발자

- 프레임워크 : 애플리케이션 코드가 프레임워크에 의해 사용되는 구조 , 개발자가 만든 코드를 프레임워크가 적절히 사용하는 구조 / 주도권이 프레임워크

→ 제어의 역전에서는 프레임워크 , 컨테이너 등 **주도권을 가지고 객체를 생성 , 생명 주기를 관리하는 존재가 필요**하다. (개발자가 제어를 하지 않기 때문에 제어를 담당할 주체가 필요하다)

### 제어의 역전 - 스프링의 관점

- 스프링에서는 **스프링 컨테이너**가 스프링 오브젝트(빈) 에 대한 생성, 생명 주기를 관리한다.

### Bean(빈)

- 스프링이 제어권을 가지고 생성하고 관리하는 오브젝트
- 스프링 컨테이너가 생성, 사용을 제어해주는 제어의 역전이 적용된 오브젝트

### 빈 팩토리

- 빈의 생성과 생명 주기 관리를 하는 IOC 컨테이너

### 애플리케이션 컨텍스트

- 빈 팩토리를 확장한 IOC 컨테이너
- 빈에 대한 생성, 생명 주기 관리 + 애플리케이션 전체적인 구성 요소에 대한 제어 작업
- ApplicationContext 라는 애플리케이션 컨텍스트로서의 기능을 수행하기 위한 인터페이스 존재

### @Configuration

- 스프링 컨테이너가 사용할 설정 정보라는 표시
- 빈을 생성(IOC 적용)하기 위한 설정을 담고 있는 클래스라는 표시

### @Bean

- 오브젝트를 생성하여 반환하는 메소드에 사용하는 어노테이션
- 해당 메소드가 수행되어 반환되는 오브젝트가 빈 오브젝트로 등록된다.

빈 팩토리에 클래스 등록 방법

```java
@Configuration  // 해당 클래스에는 객체를 반환하여 빈으로 등록하는 함수가 내포되어 있다
public class UserDtoFactory {
    @Bean // 해당 메소드가 빈 타입의 오브젝트를 생성항 반환
    public UserDto defaultUserDto()
    {
        return new UserDto();
    }
}
```

빈 객체를 반환받는 방법

```java
@SpringBootApplication
@Slf4j
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);

        ApplicationContext ac = new AnnotationConfigApplicationContext(UserDtoFactory.class);
        UserDto user = ac.getBean("defaultUserDto", UserDto.class);

        log.info("user ID : {} ", user.getUserId());
    }
}
```

UserDto user = ac.getBean("defaultUserDto", UserDto.class);

- 첫번째 인자 : 빈을 생성하여 반환하는 메소드의 이름
- 두번째 인자 : 반환되는 빈의 클래스 정보 , 기본적으로 Object 타입이 반환되는데 매번 형변환하기 귀찮….

### 애플리케이션 컨텍스트

- 기본적으로 인터페이스 형태 , 빈 팩토리를 상속 받았다
- 스프링 컨테이너 , IOC 컨테이너
- 스프링 전체적인 구성 요소 , 등록된 오브젝트에 대한 생성 , 생명 주기를 관리 ( IOC 방법이 적용 )

### 동작 방식

- 애플리케이션 컨텍스트는 @Configuration 계열의 설정정보를 통해 빈 목록을 만들어둔다.
- 클라이언트가 특정 Bean 객체를 요청
- 애플리케이션 컨텍스트가 빈 목록에서 해당 빈 객체를 탐색
- 빈 반환 메소드를 호출해서 오브젝트 생성후 클라이언트에 반환

### 애플리케이션 컨텍스트 장점

- 사용자가 정의하는 오브젝트 팩토리와 비교

1. 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
    - 개발 범위가 증가하면 오브젝트 팩토리 클래스의 개수도 증가, 복잡해진다.
    - 애플리케이션 컨텍스트 사용시 일관된 방법으로 빈 객체를 가져올 수 있다.

2. 기능의 다양성
    - 애플리케이션 컨텍스트는 단순히 오브젝트를 생성하고 관계 설정만 해주는 것이 아니다.
    - 자동생성, 오브젝트 후처리 , 설정 방식의 다변화 제공

- 스프링은 하나의 빈에 대해 여러변 요청을 해도 매번 동일한 오브젝트를 반환한다.

> 애플리케이션 컨텍스트는 빈 오브젝트를 싱글톤 패턴으로 관리하는 싱글톤 레지스트리
>

### why 싱글톤 ?

- 스프링이 사용되는 곳은 자바 엔터프라이즈 기술을 사용하는 대형 서버 환경 , 보통 하나의 요청에 대하여 계층형 처리 구조를 지나며 비즈니스 로직도 복잡하다.
- 요청이 들어올 때마다 오브젝트를 생성할 경우 부하가 걸리며 GC에도 부담이 크다.

### 싱글톤 패턴

- 애플리케이션 내에서 클래스의 인스턴스의 개수를 1개로 제한하는 방식 , 해당 오브젝트는 애플리케이션 내에서 전역적으로 접근 가능하다.

싱글톤 패턴을 적용한 클래스

```java
public class SingletonUser {
    private static SingletonUser instance; // 1. 자신의 static 인스턴스 필드
    
    private String userId;
    private String userName;
    private String userPassword; // 멀티 스레드 환경에서 다음 인스턴스 필드들은 오류를 발생!
    
    private SingletonUser(){
        this.userId = "default";
        this.userName = "default";
        this.userPassword = "default";
    } // 2. 외부에서 생성자 접근 불가능 : 생성자의 접근 지정자를 private
    
    public static synchronized SingletonUser getInstance()
    {
        if(instance==null)
            instance = new SingletonUser();
        
        return instance;
    } // 3. 하나의 인스턴스만 생성되어 관리할 수 있도록 지정
}
```

### 싱글톤 방식의 문제점 - JAVA

1. private 생성자에 의해 상속 불가능
2. 하나의 인스턴스 형태로만 존재하기 때문에 테스트하기 어렵다 .
3. 1개 이상의 JVM에 분산되어 설치되는 경우 개수를 1개로 보장할 수 없다.
4. 싱글톤 객체에 접근하는 스태틱 메서드를 통해 전역 상태로 사용되기 쉽다.

### 싱글톤 레지스트리

- 스프링은 자바 자체의 싱글톤 객체 관리가 어려운 단점을 해결하기 위해 자체적으로 싱글톤 객체를 생성하고 관리하는 기능을 제공 , 앞서 구현된 빈 등록 과정에서 개발자는 별도의 처리를 하지 않았다.
- public 생성자를 적용할 수 있으며 테스트 환경에서도 오브젝트를 생성 가능

### 싱글톤 오브젝트에 대한 고찰

- 싱글톤은 멀티 스레드 환경에서 여러 스레드가 동시에 접근하여 사용할 수 있다. 싱글톤 오브젝트에 대해 상태 정보를 내부적으로 갖지 않는 (stateless)무상태 방식이여야 한다. 인스턴스 필드 값을 변경하고 유지하는 상태 유지 방식의 경우 멀티 스레드 환경에서 충돌이 일어날 수 있다.
- 단 , 자신이 사용하는 다른 싱글톤 빈을 인스턴스 변수로 사용한다면 문제는 없다.
    - 결국 인스턴스로 사용되는 빈도 스프링이 관리하기 때문에 싱글톤 객체로서 관리되기 때문이다.

### 빈의 스코프

- 빈이 생성되고 적용되는 범위
- 기본적으로 싱글톤 스코프이기 때문에 스프링 컨테이너가 존재하는 동안 계속 유지
- 프로토타입 스코프 : 빈을 요청할 때마다 새로운 오브젝트를 생성하여 반환
- 요청 스코프 : HTTP 요청이 생길 때마다 생성
- 세션 스코프
