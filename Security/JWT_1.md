# JWT (개념)

## 인증

- 서버로 온 요청에 대해 클라이언트(사용자)를 식별하는 방법에는 크게 **세션**과 **토큰**이 있다.

### HTTP

> 인터넷 상에서 서버와 클라이언트는 데이터를 주고 받기 위해 **HTTP 프로토콜을 사용**한다. HTTP에는 **무상태성** , **비연결성**이라는 중요한 특징이 있다.
>
1. **무상태성 (Stateless)**
    - 서버가 **클라이언트의 상태를 보존하지 않는다.**
    - 클라이언트의 매 요청은 **독립적이다 !**
- **WHY ?**

  서버의 수평 확장에 유리하기 때문이다. 하지만 데이터를 지속해서 요청때마다 보내야 한다.

1. **비연결성**
    - HTTP의 경우 연결을 유지하지 않는다. Request에 대한 처리 과정에서만 연결을 유지하고 응답을 한 경우 **TCP/IP 연결이 끊어진다.**
- **WHY ?**

  인터넷 상에서 **다수의 통신을 기반으로 설계된 프로토콜** , 연결을 계속 유지한다면 리소스가 많이 발생 (낭비의 영역)

- **HTTP와 인증**
    1. 인증이란 사용자를 식별하는 것이다. 즉 **상태 유지의 개념이 포함**되어 있다는 것이다. HTTP는 기본적으로 **무상태성**이기 때문에 사이의 괴리를 해결하는 것이 핵심이다.
    2. 사용자가 로그인을 하기 위해서는 개인적 정보가 요구된다. 해당 **정보를 어떻게 요청**하는지도 고려해야 한다.
        - ***어떤 바구니에 어떤 포장지로 담을것인가 ?***

### 쿠키

- 클라이언트가 웹 사이트를 방문할 경우 웹 사이트의 서버가 **클라이언트의 브라우저에 전송하는 데이터**
- 브라우저는 데이터를 저장해놓고 동일한 웹 사이트에 재 접근시 데이터(쿠키)를 함께 전송
    - 쿠키 : Key - Value 형식의 문자열
- **첫번째 접근**

  인증이 필요한 웹 사이트에 접근하는 경우 **사용자 정보를 쿠키에 저장**한다면 매번 로그인하지 않아도 된다 !

- 해커가 사랑한다.
    1. 사용자의 정보를 그대로 담는다면 보안에 취약할 것이다.

  > 클라이언트는 서버에 비해 보안이 취약하다. 사용자의 **Raw Data를 클라이언트가 아닌 서버 쪽에서 관리하도록 하자 !**
  
### 세션

- HTTP 세션
    - 클라이언트가 브라우저를 통해 서버에 접속하여 종료되는 연결 시간 단위
- 클라이언트의 **인증 정보를 서버에 저장**한다.
    - 즉 서버의 Session DB에 클라이언트의 Raw Data를 저장
    - 쿠키에는 변환된 Session - Id를 저장
- 인증이 완료되었다면 세션 유효 기간동안 클라이언트는 Session - Id로 웹 사이트에 접근한다.

![Untitled](https://user-images.githubusercontent.com/84346055/277939604-b4c41f85-40e5-4d9e-b82d-dae0df8a7566.png)

- ***즉 세션을 이용한다면 쿠키는 단순한 전달 매개체 (포장지)가 되버리는 것이다 !***

**세션 저장 방식**

- 웹 서버 내장 메모리
    - 한 개의 **WAS내에서 세션이 저장되고 관리**된다. 2대 이상의 WAS가 돌아가는 환경에서는 공유가 필요하다.
    - 로드밸런서를 사용하는 경우에는 사용할 수 없다.
- DBMS
    - 세션 자체를 하나의 DB에서 관리하는 개념 → 서버가 여러 대 구성해도 작동 가능하다.
        - 클라이언트의 요청이 많은 경우 1개의 DB에서 부하를 담당하기 때문에 작동이 어려울 수 있다.
- Redis (인메모리)
    - 가장 많이 사용하는 방식 → 속도가 빠르고 휘발성으로 데이터를 저장한다.
- **두번째 접근**
    - 서버와 클라이언트간의 통신은 HTTP 프로토콜을 사용하고 HTTP는 무상태성에 기초하고 있다. 하지만 클라이언트(단순 쿠키) , 서버(Session DB)를 사용하는 것은 상태성을 유지하는 방식이고 이 사이의 괴리가 있다.
    - **변환된 사용자의 정보를 보내는 것만으로 인증이 완료되게 할 수는 없을까 ?**
        - **서버 입장에서는 별도의 DB를 거치지 않고 인증을 처리할 수 없을까 ?**

## 토큰

> 토큰이란 **인증된 사용자에 대한 승인을 변환한 문자열**이다.
>

**동작 방식**

1. 서버는 인증된 클라이언트에게 토큰을 발급한다. (사용자의 정보로 토큰을 생성)
2. 클라이언트는 서버에 요청시마다 토큰을 담아 보낸다.
3. 서버는 클라이언트의 **토큰을 해독하여 유효한 요청임을 검증**한다.

**검증 !**

- 별도의 DB를 사용하지 않아도 된다 → Refresh Token을 사용한다면 조금 달라지지만…

### JWT

- Json Web Token
    - 인증과 인가에서 사용되는 **JSON 형식의 토큰에 대한 규격**
    - Http의 Authorization 헤더에 Bearer <token> 형식으로 전송
- 구조
    - 헤더
        - 토큰의 유형 , 서명 알고리즘
            - typ : 토큰의 유형(type)
            - alg : 서명 알고리즘(algorithm)
    - 페이로드
        - **claim** : 사용자 인증 , 인가 정보
            - **sub : 인증 주체(subject)**
            - iss : 토큰 발급처
            - iat : 발급 시각(issued at)
            - **exp : 만료 시작(expiration time)**
            - aud : 클라이언트(audience)
    - 서명
        - 헤더의 인코딩 값 , 페이로드의 인코딩 값을 Secret Key로 서명
- 문자열 구조
    - <헤더>.<페이로드>.<서명> 의 문자열

### 장점

- 서버가 다수 존재하는 환경에서 유용하다. 세션을 사용하면 모든 서버에서 세션 내용을 공유해야 하기 때문
- 매 요청시마다 DB 조회를 하지 않고 토큰 자체만으로 사용자의 정보와 권한을 알 수 있기에 병목현상 방지
    - 하지만 JPA사용의 경우에 이렇게 엔티티를 가져왔을 때 영속 상태는 아님!

### 단점과 고려할 점들

- Self-contained
    - 토큰 자체에 정보를 담고 있으므로 양날의 검이 될 수 있다.
- 토큰 길이
    - 토큰의 페이로드(Payload)에 3종류의 클레임을 저장하기 때문에, 정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부하를 줄 수 있다.
- Payload 인코딩
    - 페이로드(Payload) 자체는 암호화 된 것이 아니라, BASE64Url로 인코딩 된 것이다. 중간에 Payload를 탈취하여 디코딩하면 데이터를 볼 수 있으므로, JWE로 암호화하거나 Payload에 중요 데이터를 넣지 않아야 한다.
- Stateless
    - JWT는 상태를 저장하지 않기 때문에 한번 만들어지면 제어가 불가능하다. 즉, 토큰을 임의로 삭제하는 것이 불가능하므로 토큰 만료 시간을 꼭 넣어주어야 한다.
- Tore Token
    - 토큰은 클라이언트 측에서 관리해야 하기 때문에, 토큰을 저장해야 한다.

## 참고

[[네트워크] HTTP 쿠키와 세션이란 ?](https://noahlogs.tistory.com/38)

[[10분 테코톡] 🎡토니의 인증과 인가](https://www.youtube.com/watch?v=y0xMXlOAfss&t=944s)

[[정보보안] REST JWT(JSON Web Token) 이란?](https://12bme.tistory.com/130)
